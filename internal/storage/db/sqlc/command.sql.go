// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: command.sql

package sqlc

import (
	"context"
)

const commandCancelByStatusQueuedAndProcessingAndCanceling = `-- name: CommandCancelByStatusQueuedAndProcessingAndCanceling :exec
UPDATE
	commands
SET
	status = 'CANCELED'
WHERE
	status IN ('QUEUED', 'PROCESSING', 'CANCELING')
`

func (q *Queries) CommandCancelByStatusQueuedAndProcessingAndCanceling(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, commandCancelByStatusQueuedAndProcessingAndCanceling)
	return err
}

const commandCancelByStatusQueuedAndProcessingAndCreatedByCloud = `-- name: CommandCancelByStatusQueuedAndProcessingAndCreatedByCloud :exec
UPDATE
	commands
SET
	status = 'CANCELED'
WHERE
	status IN ('QUEUED', 'PROCESSING')
	AND source = 'CLOUD'
`

func (q *Queries) CommandCancelByStatusQueuedAndProcessingAndCreatedByCloud(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, commandCancelByStatusQueuedAndProcessingAndCreatedByCloud)
	return err
}

const commandCreate = `-- name: CommandCreate :one
INSERT INTO
	commands (
		type,
		status,
		source,
		inputs,
		error,
		started_at,
		created_at,
		updated_at,
		completed_at,
		request_id
	)
VALUES
	(
		?1,
		?2,
		?3,
		?4,
		?5,
		?6,
		?7,
		?8,
		?9,
		?10
	) RETURNING id,
	outputs
`

type CommandCreateParams struct {
	Type        string  `json:"type"`
	Status      string  `json:"status"`
	Source      string  `json:"source"`
	Inputs      string  `json:"inputs"`
	Error       *string `json:"error"`
	StartedAt   *string `json:"started_at"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	CompletedAt *string `json:"completed_at"`
	RequestID   *string `json:"request_id"`
}

type CommandCreateRow struct {
	ID      int64  `json:"id"`
	Outputs string `json:"outputs"`
}

func (q *Queries) CommandCreate(ctx context.Context, db DBTX, arg CommandCreateParams) (CommandCreateRow, error) {
	row := db.QueryRowContext(ctx, commandCreate,
		arg.Type,
		arg.Status,
		arg.Source,
		arg.Inputs,
		arg.Error,
		arg.StartedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.RequestID,
	)
	var i CommandCreateRow
	err := row.Scan(&i.ID, &i.Outputs)
	return i, err
}

const commandDeleteByID = `-- name: CommandDeleteByID :execrows
DELETE FROM
	commands
WHERE
	id = ?1
	AND status NOT IN ('PROCESSING', 'CANCELING')
`

// It does not delete the command if the status is PROCESSING, CANCELING.
func (q *Queries) CommandDeleteByID(ctx context.Context, db DBTX, id int64) (int64, error) {
	result, err := db.ExecContext(ctx, commandDeleteByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const commandDeleteOldCommands = `-- name: CommandDeleteOldCommands :execrows
DELETE FROM
	commands
WHERE
	created_at < ?1
	AND status NOT IN ('QUEUED', 'PROCESSING', 'CANCELING')
`

// It does not delete the command if the status is QUEUED, PROCESSING, CANCELING.
func (q *Queries) CommandDeleteOldCommands(ctx context.Context, db DBTX, createdAt string) (int64, error) {
	result, err := db.ExecContext(ctx, commandDeleteOldCommands, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const commandGetByID = `-- name: CommandGetByID :one
SELECT
	id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs, request_id
FROM
	commands
WHERE
	id = ?1
`

func (q *Queries) CommandGetByID(ctx context.Context, db DBTX, id int64) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetByID, id)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
		&i.RequestID,
	)
	return i, err
}

const commandGetCurrentProcessing = `-- name: CommandGetCurrentProcessing :one
SELECT
	id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs, request_id
FROM
	commands
WHERE
	status IN ('PROCESSING', 'CANCELING')
LIMIT
	1
`

// It returns the command with the status PROCESSING or CANCELING.
// Should be only one command in status PROCESSING or CANCELING.
func (q *Queries) CommandGetCurrentProcessing(ctx context.Context, db DBTX) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetCurrentProcessing)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
		&i.RequestID,
	)
	return i, err
}

const commandGetNextExecutable = `-- name: CommandGetNextExecutable :one
SELECT
	id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs, request_id
FROM
	commands
WHERE
	status = 'QUEUED'
ORDER BY
	created_at ASC
LIMIT
	1
`

func (q *Queries) CommandGetNextExecutable(ctx context.Context, db DBTX) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetNextExecutable)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
		&i.RequestID,
	)
	return i, err
}

const commandUpdate = `-- name: CommandUpdate :one
UPDATE
	commands
SET
	status = CASE
		WHEN ?1 = 1 THEN ?2
		ELSE status
	END,
	outputs = CASE
		WHEN ?3 = 1 THEN ?4
		ELSE outputs
	END,
	error = CASE
		WHEN ?5 = 1 THEN ?6
		ELSE error
	END,
	started_at = CASE
		WHEN ?7 = 1 THEN ?8
		ELSE started_at
	END,
	completed_at = CASE
		WHEN ?9 = 1 THEN ?10
		ELSE completed_at
	END,
	updated_at = ?11
WHERE
	id = ?12 RETURNING id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs, request_id
`

type CommandUpdateParams struct {
	SetStatus      interface{} `json:"set_status"`
	Status         string      `json:"status"`
	SetOutputs     interface{} `json:"set_outputs"`
	Outputs        string      `json:"outputs"`
	SetError       interface{} `json:"set_error"`
	Error          *string     `json:"error"`
	SetStartedAt   interface{} `json:"set_started_at"`
	StartedAt      *string     `json:"started_at"`
	SetCompletedAt interface{} `json:"set_completed_at"`
	CompletedAt    *string     `json:"completed_at"`
	UpdatedAt      string      `json:"updated_at"`
	ID             int64       `json:"id"`
}

func (q *Queries) CommandUpdate(ctx context.Context, db DBTX, arg CommandUpdateParams) (Command, error) {
	row := db.QueryRowContext(ctx, commandUpdate,
		arg.SetStatus,
		arg.Status,
		arg.SetOutputs,
		arg.Outputs,
		arg.SetError,
		arg.Error,
		arg.SetStartedAt,
		arg.StartedAt,
		arg.SetCompletedAt,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
		&i.RequestID,
	)
	return i, err
}
