// Code generated by mockery v2.53.1. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	db "github.com/tbe-team/raybot/internal/storage/db"

	model "github.com/tbe-team/raybot/internal/model"

	paging "github.com/tbe-team/raybot/pkg/paging"

	repository "github.com/tbe-team/raybot/internal/repository"

	sort "github.com/tbe-team/raybot/pkg/sort"
)

// FakeCommandRepository is an autogenerated mock type for the CommandRepository type
type FakeCommandRepository struct {
	mock.Mock
}

type FakeCommandRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *FakeCommandRepository) EXPECT() *FakeCommandRepository_Expecter {
	return &FakeCommandRepository_Expecter{mock: &_m.Mock}
}

// CreateCommand provides a mock function with given fields: ctx, _a1, command
func (_m *FakeCommandRepository) CreateCommand(ctx context.Context, _a1 db.SQLDB, command model.Command) error {
	ret := _m.Called(ctx, _a1, command)

	if len(ret) == 0 {
		panic("no return value specified for CreateCommand")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, model.Command) error); ok {
		r0 = rf(ctx, _a1, command)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FakeCommandRepository_CreateCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCommand'
type FakeCommandRepository_CreateCommand_Call struct {
	*mock.Call
}

// CreateCommand is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 db.SQLDB
//   - command model.Command
func (_e *FakeCommandRepository_Expecter) CreateCommand(ctx interface{}, _a1 interface{}, command interface{}) *FakeCommandRepository_CreateCommand_Call {
	return &FakeCommandRepository_CreateCommand_Call{Call: _e.mock.On("CreateCommand", ctx, _a1, command)}
}

func (_c *FakeCommandRepository_CreateCommand_Call) Run(run func(ctx context.Context, _a1 db.SQLDB, command model.Command)) *FakeCommandRepository_CreateCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.SQLDB), args[2].(model.Command))
	})
	return _c
}

func (_c *FakeCommandRepository_CreateCommand_Call) Return(_a0 error) *FakeCommandRepository_CreateCommand_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FakeCommandRepository_CreateCommand_Call) RunAndReturn(run func(context.Context, db.SQLDB, model.Command) error) *FakeCommandRepository_CreateCommand_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommandByID provides a mock function with given fields: ctx, _a1, id
func (_m *FakeCommandRepository) GetCommandByID(ctx context.Context, _a1 db.SQLDB, id string) (model.Command, error) {
	ret := _m.Called(ctx, _a1, id)

	if len(ret) == 0 {
		panic("no return value specified for GetCommandByID")
	}

	var r0 model.Command
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, string) (model.Command, error)); ok {
		return rf(ctx, _a1, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, string) model.Command); ok {
		r0 = rf(ctx, _a1, id)
	} else {
		r0 = ret.Get(0).(model.Command)
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.SQLDB, string) error); ok {
		r1 = rf(ctx, _a1, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FakeCommandRepository_GetCommandByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommandByID'
type FakeCommandRepository_GetCommandByID_Call struct {
	*mock.Call
}

// GetCommandByID is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 db.SQLDB
//   - id string
func (_e *FakeCommandRepository_Expecter) GetCommandByID(ctx interface{}, _a1 interface{}, id interface{}) *FakeCommandRepository_GetCommandByID_Call {
	return &FakeCommandRepository_GetCommandByID_Call{Call: _e.mock.On("GetCommandByID", ctx, _a1, id)}
}

func (_c *FakeCommandRepository_GetCommandByID_Call) Run(run func(ctx context.Context, _a1 db.SQLDB, id string)) *FakeCommandRepository_GetCommandByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.SQLDB), args[2].(string))
	})
	return _c
}

func (_c *FakeCommandRepository_GetCommandByID_Call) Return(_a0 model.Command, _a1 error) *FakeCommandRepository_GetCommandByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FakeCommandRepository_GetCommandByID_Call) RunAndReturn(run func(context.Context, db.SQLDB, string) (model.Command, error)) *FakeCommandRepository_GetCommandByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommandByStatusInProgress provides a mock function with given fields: ctx, _a1
func (_m *FakeCommandRepository) GetCommandByStatusInProgress(ctx context.Context, _a1 db.SQLDB) (model.Command, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetCommandByStatusInProgress")
	}

	var r0 model.Command
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB) (model.Command, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB) model.Command); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Get(0).(model.Command)
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.SQLDB) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FakeCommandRepository_GetCommandByStatusInProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommandByStatusInProgress'
type FakeCommandRepository_GetCommandByStatusInProgress_Call struct {
	*mock.Call
}

// GetCommandByStatusInProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 db.SQLDB
func (_e *FakeCommandRepository_Expecter) GetCommandByStatusInProgress(ctx interface{}, _a1 interface{}) *FakeCommandRepository_GetCommandByStatusInProgress_Call {
	return &FakeCommandRepository_GetCommandByStatusInProgress_Call{Call: _e.mock.On("GetCommandByStatusInProgress", ctx, _a1)}
}

func (_c *FakeCommandRepository_GetCommandByStatusInProgress_Call) Run(run func(ctx context.Context, _a1 db.SQLDB)) *FakeCommandRepository_GetCommandByStatusInProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.SQLDB))
	})
	return _c
}

func (_c *FakeCommandRepository_GetCommandByStatusInProgress_Call) Return(_a0 model.Command, _a1 error) *FakeCommandRepository_GetCommandByStatusInProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FakeCommandRepository_GetCommandByStatusInProgress_Call) RunAndReturn(run func(context.Context, db.SQLDB) (model.Command, error)) *FakeCommandRepository_GetCommandByStatusInProgress_Call {
	_c.Call.Return(run)
	return _c
}

// ListCommands provides a mock function with given fields: ctx, _a1, params, sorts
func (_m *FakeCommandRepository) ListCommands(ctx context.Context, _a1 db.SQLDB, params paging.Params, sorts []sort.Sort) (paging.List[model.Command], error) {
	ret := _m.Called(ctx, _a1, params, sorts)

	if len(ret) == 0 {
		panic("no return value specified for ListCommands")
	}

	var r0 paging.List[model.Command]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, paging.Params, []sort.Sort) (paging.List[model.Command], error)); ok {
		return rf(ctx, _a1, params, sorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, paging.Params, []sort.Sort) paging.List[model.Command]); ok {
		r0 = rf(ctx, _a1, params, sorts)
	} else {
		r0 = ret.Get(0).(paging.List[model.Command])
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.SQLDB, paging.Params, []sort.Sort) error); ok {
		r1 = rf(ctx, _a1, params, sorts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FakeCommandRepository_ListCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCommands'
type FakeCommandRepository_ListCommands_Call struct {
	*mock.Call
}

// ListCommands is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 db.SQLDB
//   - params paging.Params
//   - sorts []sort.Sort
func (_e *FakeCommandRepository_Expecter) ListCommands(ctx interface{}, _a1 interface{}, params interface{}, sorts interface{}) *FakeCommandRepository_ListCommands_Call {
	return &FakeCommandRepository_ListCommands_Call{Call: _e.mock.On("ListCommands", ctx, _a1, params, sorts)}
}

func (_c *FakeCommandRepository_ListCommands_Call) Run(run func(ctx context.Context, _a1 db.SQLDB, params paging.Params, sorts []sort.Sort)) *FakeCommandRepository_ListCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.SQLDB), args[2].(paging.Params), args[3].([]sort.Sort))
	})
	return _c
}

func (_c *FakeCommandRepository_ListCommands_Call) Return(_a0 paging.List[model.Command], _a1 error) *FakeCommandRepository_ListCommands_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FakeCommandRepository_ListCommands_Call) RunAndReturn(run func(context.Context, db.SQLDB, paging.Params, []sort.Sort) (paging.List[model.Command], error)) *FakeCommandRepository_ListCommands_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCommand provides a mock function with given fields: ctx, _a1, params
func (_m *FakeCommandRepository) UpdateCommand(ctx context.Context, _a1 db.SQLDB, params repository.UpdateCommandParams) (model.Command, error) {
	ret := _m.Called(ctx, _a1, params)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCommand")
	}

	var r0 model.Command
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, repository.UpdateCommandParams) (model.Command, error)); ok {
		return rf(ctx, _a1, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.SQLDB, repository.UpdateCommandParams) model.Command); ok {
		r0 = rf(ctx, _a1, params)
	} else {
		r0 = ret.Get(0).(model.Command)
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.SQLDB, repository.UpdateCommandParams) error); ok {
		r1 = rf(ctx, _a1, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FakeCommandRepository_UpdateCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCommand'
type FakeCommandRepository_UpdateCommand_Call struct {
	*mock.Call
}

// UpdateCommand is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 db.SQLDB
//   - params repository.UpdateCommandParams
func (_e *FakeCommandRepository_Expecter) UpdateCommand(ctx interface{}, _a1 interface{}, params interface{}) *FakeCommandRepository_UpdateCommand_Call {
	return &FakeCommandRepository_UpdateCommand_Call{Call: _e.mock.On("UpdateCommand", ctx, _a1, params)}
}

func (_c *FakeCommandRepository_UpdateCommand_Call) Run(run func(ctx context.Context, _a1 db.SQLDB, params repository.UpdateCommandParams)) *FakeCommandRepository_UpdateCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.SQLDB), args[2].(repository.UpdateCommandParams))
	})
	return _c
}

func (_c *FakeCommandRepository_UpdateCommand_Call) Return(_a0 model.Command, _a1 error) *FakeCommandRepository_UpdateCommand_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FakeCommandRepository_UpdateCommand_Call) RunAndReturn(run func(context.Context, db.SQLDB, repository.UpdateCommandParams) (model.Command, error)) *FakeCommandRepository_UpdateCommand_Call {
	_c.Call.Return(run)
	return _c
}

// NewFakeCommandRepository creates a new instance of FakeCommandRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFakeCommandRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *FakeCommandRepository {
	mock := &FakeCommandRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
